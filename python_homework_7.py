#!/usr/bin/env python
# coding: utf-8

# In[1]:


# 1) Реализовать класс ​Matrix ​(матрица). Обеспечить перегрузку конструктора класса (метод 
# __init__()​), который должен принимать данные (список списков) для формирования матрицы. 

# Подсказка: матрица — ​система некоторых математических величин, расположенных в виде 
# прямоугольной схемы. 

# Примеры матриц: 3 на 2, 3 на 3, 2 на 4. 

 

# Следующий шаг — реализовать перегрузку метода ​__str__() для вывода матрицы в 
# привычном виде. 

# Далее реализовать перегрузку метода ​__add__() для реализации операции сложения двух 
# объектов класса ​Matrix ​(двух матриц). Результатом сложения должна быть новая матрица.  

# Подсказка: сложение элементов матриц выполнять поэлементно — первый элемент первой 
# строки первой матрицы складываем с первым элементом первой строки второй матрицы и т.д. 


# In[1]:


class Matrix():
    def __init__(self, matrix):
        self.matrix = matrix
        
    def __str__(self):
        return '\n'.join(['\t'.join([str(el) for el in i]) for i in self.matrix])
    
    def __add__(self, sum_matrix):
        return Matrix([[a + b for a, b in zip(x, y)] for x, y in zip(self.matrix, sum_matrix.matrix)])


# In[5]:


m = Matrix([[5, 3, 1], [-6, 5, 1], [4, 10, -1], [12, 1, 1]])
m2 = Matrix([[1, 10, 31], [-1, 5, 7], [3, 1, -1], [-6, 1, -1]])


# In[6]:


print(m+m2)


# In[2]:


# 2) Реализовать проект расчета суммарного расхода ткани на производство одежды. Основная 
# сущность (класс) этого проекта — ​одежда​, которая может иметь определенное название. К 
# типам одежды в этом проекте относятся ​пальто ​и ​костюм​. У этих типов одежды существуют 
# параметры: ​размер ​(для ​пальто​) ​и ​рост ​(для ​костюма​). Это могут быть обычные числа: ​V и 
# H​, соответственно.  

# Для определения расхода ткани по каждому типу одежды использовать формулы: для пальто 
# (V/6.5 + 0.5)​, для костюма ​(2*H + 0.3)​. Проверить работу этих методов на реальных данных. 

# Реализовать общий подсчет расхода ткани. Проверить на практике полученные на этом уроке 
# знания: реализовать абстрактные классы для основных классов проекта, проверить на 
# практике работу декоратора ​@property​. 


# In[7]:


class Clothes:
    def __init__(self, name):
        self.name = name


class Coat(Clothes):
    def __init__(self, name, size):
        super().__init__(name)
        self.size = size

    @property
    def total(self):
        return self.size / 6.5 + 0.5


class Suit(Clothes):
    def __init__(self, name, growth):
        super().__init__(name)
        self.growth = growth

    @property
    def total(self):
        return 2 * self.growth + 0.3


def total_issue(*args, s=0):
    return sum(i.total for i in args)


a1 = Coat('coat_1', 50)
a2 = Suit('suit_1', 170)
a3 = Coat('coat_2', 50)
a4 = Suit('suit_2', 170)
a5 = Coat('coat_3', 50)
print(total_issue(*[a1, a2, a3, a4, a5]))


# In[ ]:


# 3) Реализовать программу работы с органическими клетками, состоящими из ячеек. Необходимо 
# создать класс Клетка. В его конструкторе инициализировать параметр, соответствующий 
# количеству ячеек клетки (целое число). В классе должны быть реализованы методы перегрузки арифметических операторов: сложение (​__add__()​), вычитание (​__sub__()​), 
# умножение (​__mul__()​), деление (​__truediv__()​). Данные методы должны применяться ​только 
# к клеткам и выполнять увеличение, уменьшение, умножение и целочисленное (с округлением 
# до целого) деление клеток, соответственно. 

# Сложение​. Объединение двух клеток. При этом число ячеек общей клетки должно равняться 
# сумме ячеек исходных двух клеток. 

# Вычитание​. Участвуют две клетки. Операцию необходимо выполнять только если разность 
# количества ячеек двух клеток больше нуля, иначе выводить соответствующее сообщение. 

# Умножение​. Создается общая клетка из двух. Число ячеек общей клетки определяется как 
# произведение количества ячеек этих двух клеток. 

# Деление​. Создается общая клетка из двух. Число ячеек общей клетки определяется как 
# целочисленное деление количества ячеек этих двух клеток. 

# В классе необходимо реализовать метод ​make_order()​, принимающий экземпляр класса и 
# количество ячеек в ряду. Данный метод позволяет организовать ячейки по рядам. 

# Метод должен возвращать строку вида ​*****\n*****\n*****​..., где количество ячеек между ​\n 
# равно переданному аргументу. Если ячеек на формирование ряда не хватает, то в последний 
# ряд записываются все оставшиеся. 

# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. Тогда метод 
# make_order() ​вернет строку: ​*****\n*****\n**.​ 

# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. Тогда метод 
# make_order() ​вернет строку: ​*****\n*****\n*****​. 


# In[132]:


class Cell():
    def __init__(self, quant_one, quant_two):
        self.quant_one = quant_one
        self.quant_two = quant_two
        
    def __add__(self): 
        return self.quant_one + self.quant_two
    
    def __sub__(self): 
        result = self.quant_one - self.quant_two
        if result < 0:
            return f'Операция невозможна!'
        else:
            return result
    
    def __mul__(self): 
        return self.quant_one * self.quant_two
    
    def __truediv__(self): 
        return self.quant_one // self.quant_two
    
    def make_order(self, rows):
        self =  self.quant_one
        r = ''
        for i in range(rows):
            r += '*' * int(self / rows) + '\n' 
        r += '*' * int(self % rows) 
        return r
    
a = Cell(10, 20)

print(a.__add__())
print(a.__sub__())
print(a.__mul__())
print(a.__truediv__())
print(a.make_order(3))

